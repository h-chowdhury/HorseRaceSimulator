package Part2;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.Timer;
import javax.swing.ImageIcon;
import javax.swing.JPanel;

/**
 * This class defines the race panel.
 * The horse race animation will be displayed within this panel.
 * 
 * @author Humayra Chowdhury
 * @version Version 2.6
 */
public class RacePanel extends JPanel implements ActionListener {

  // Class variables of RacePanel
  private RaceData raceData;
  private int numberOfHorses;
  private int trackLength;
  private int laneCount;

  private Horse[] lanes;
  private Image[] horseSymbols;

  private double FINISH_LINE_X;
  private String raceWinner;

  private Timer timer;

  final int PANEL_HEIGHT = 620;
  final int PANEL_WIDTH = 1090;

  int[] xPosTrack;
  int[] yPosTrack;


  /**
   * Constructor of RacePanel
   */
  RacePanel (RaceData RD) {

    raceData = RD;

    numberOfHorses = raceData.getNumberOfHorses();
    trackLength = raceData.getLengthOfTrack();
    laneCount = raceData.getNumberOfLanes();
    lanes = raceData.getLanesArray();

    horseSymbols = new Image[laneCount];
    FINISH_LINE_X = (PANEL_WIDTH-45) * ((double) trackLength/500.0); // PANEL_WIDTH-45 is full length (500m)


    // Positional values for horses and track lines
      // Set velocity values (default = 5)
      setHorseVelocities();

      // Set positional values of horses (x and y)
      setHorsePositions();

      // Set positional values of track (x and y)
      setTrackPositions();


    this.setPreferredSize(new Dimension(PANEL_WIDTH, PANEL_HEIGHT));
    this.setBackground(new Color(0xE7D176));

    // set placeholder images into image array
    for (int i=0; i<laneCount; i++) {
      horseSymbols[i]= new ImageIcon("C:\\Users\\hummu\\Documents\\Uni\\Year 1\\Semester B\\Object Oriented Programming\\Project\\HorseRaceSimulator\\Part2\\images\\placeholder.png").getImage();
    }

    timer = new Timer(100, this);
    timer.start();
  
  }

  /**
   * Draws the race components such as the horses and track lines.
   * @param g the graphics component that allows for drawing.
   */
  public void paintComponent(Graphics g) {
    super.paintComponent(g); // paints bg
    Graphics2D g2D = (Graphics2D) g;

    // draw the track lines and start/finish lines
    drawTrackLines(g2D);

    // update each horse repeatedly
    drawHorses(g2D);
  }


  /**
   * Moves the horses every 100 miliseconds
   * @param e represents the event generated by the Timer
   */
  @Override
  public void actionPerformed(ActionEvent e) {
    moveHorses();

    //if any of the horses has won the race is finished
    //if all of the three horses have fallen the race is finished
    if (allHaveFallen() || raceWonByAny()) {
        timer.stop();

        // Return null if there is no winner
        if (allHaveFallen()) {
          raceWinner = null;
        }
        else {
          raceWinner = getWinner();
        }
    }
  
  }


  /**
   * Draws the track lines of the racing track including the
   * start and finish lines.
   * @param g2D The graphics object that allows for drawing
   */
  private void drawTrackLines(Graphics2D g2D) {
    // draw track lines
    for (int i=0; i<laneCount; i++) {
      g2D.drawLine(xPosTrack[i], yPosTrack[i], (int) FINISH_LINE_X, yPosTrack[i]);
    }

    // draw one extra line at bottom to close the last lane
    int lastY = yPosTrack[laneCount]; // add lane height
    g2D.drawLine(xPosTrack[0], lastY, (int) FINISH_LINE_X, lastY);

    // draw start line
    g2D.drawLine(xPosTrack[0], yPosTrack[0], xPosTrack[0], yPosTrack[laneCount]);

    // draw finish line
    g2D.drawLine((int) FINISH_LINE_X, yPosTrack[0], (int) FINISH_LINE_X, yPosTrack[laneCount]);
  }


  /**
   * Draws the horses with updated positions to the panel
   * @param g2D The graphics object that allows for drawing
   */
  private void drawHorses(Graphics2D g2D) {
    // update each horse repeatedly
    for (int  i=0; i<laneCount; i++) {
      if (lanes[i] != null) {
        g2D.drawImage(horseSymbols[i], lanes[i].getXpos(), lanes[i].getYpos(), null);
      }
    }
  }


  /**
   * Updates the positions of the horses (xPos) according to factors such
   * as the horse's confidence level.
   * May cause a horse to fall.
   */
  private void moveHorses() {
    // update each horses x position repeatedly
    for (int i=0; i<laneCount; i++) {
      // Check if the lane value is null (empty lane)
      if (lanes[i] != null && lanes[i].getXpos() <= FINISH_LINE_X && (lanes[i].hasFallen() == false)) {

        //the probability that the horse will move forward depends on the confidence;
        if (Math.random() < lanes[i].getConfidence())
        {
          int xPos = lanes[i].getXpos();
          int xVelocity = lanes[i].getXVelocity();
          lanes[i].setXpos(xPos + xVelocity);
        }
        
        //the probability that the horse will fall is very small (max is 0.1)
        //but will also will depends exponentially on confidence 
        //so if you double the confidence, the probability that it will fall is *2
        if (Math.random() < (0.1*lanes[i].getConfidence()/16))
        {
          lanes[i].fall();
          // Set horse icon to an X to indicate it has fallen
          horseSymbols[i]= new ImageIcon("C:\\Users\\hummu\\Documents\\Uni\\Year 1\\Semester B\\Object Oriented Programming\\Project\\HorseRaceSimulator\\Part2\\images\\cross.png").getImage();
        }
      }
    }
    repaint();
  }


  /**
   * Sets the values of each horses velocity
   * Current default values are xVel=5, yVel=1
   */
  public void setHorseVelocities () {
    for (int i=0; i<laneCount; i++) {
      // Check if the lane value is null (empty lane)
      if (lanes[i] != null) {
        lanes[i].setXVelocity(5);
        lanes[i].setYVelocity(1);
      }
    }
  }


  /**
   * Sets the values of each horses x and y positions
   */
  public void setHorsePositions () {
    for (int i=0; i<laneCount; i++) {
      // Check if the lane value is null (empty lane)
      if (lanes[i] != null) {
        lanes[i].setXpos(5);
        lanes[i].setYpos(7 + (i*25)); 
      }
    }
  }


   /**
   * Sets the values of track x and y positions
   */
  public void setTrackPositions () {
    xPosTrack = new int[laneCount + 1];
    yPosTrack = new int[laneCount + 1];
    
    for (int i=0; i<=laneCount; i++) {
      xPosTrack[i] = 5;
      yPosTrack[i] = 5 + (i*25);
    }
  }


  /** 
   * Determines if a horse has won the race
   *
   * @param theHorse The horse we are testing
   * @return true if the horse has won, false otherwise.
   */
  private boolean raceWonBy(Horse theHorse) {
    if (theHorse.getXpos() >= FINISH_LINE_X)
    {
      return true;
    }
    return false;
  }


  /** 
   * Determines if any horse has won the race
   * Uses the raceWonBy method
   */
  private boolean raceWonByAny()
  {
      for (int i=0; i<lanes.length; i++) {
          if (lanes[i] != null && raceWonBy(lanes[i]) == true) {
              raceWinner = lanes[i].getName();
              return true;
          }
          
      }
      return false;
  }


  /** 
   * Determines if all horses have fallen
   * Ends the race if this is true.
   */
  private boolean allHaveFallen() {
      for (int i=0; i<lanes.length; i++) {
          if (lanes[i] != null && lanes[i].hasFallen() != true) {
              return false;
          }  
      }
      return true;
  }


  private String getWinner() {
    for (int i=0; i<lanes.length; i++) {
      if (lanes[i] != null && lanes[i].getXpos() >= FINISH_LINE_X) {
          return lanes[i].getName();
      }  
    }
    // fall-back return type in case of error
    return null;
  }


}
